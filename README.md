# 纯粹的抽卡决斗

## 🎯 设计目标

打造一款节奏紧凑的双人抽卡对决游戏，核心体验围绕「随机抽牌 + 分数博弈 + 小规模运营」，同时通过层级推进、旅行商人和收藏要素制造出连续的惊喜感与逆转空间。

## 🧱 游戏结构概要

| 层级 | 关键事件 | 玩家初始状态 | 特殊规则 |
| --- | --- | --- | --- |
| 第 1 层 | Entrance | $score=1$，无加成 | 标准卡池 |
| 第 2 层 | Deepening | 保留上一层滞留卡 | 开放部分进阶卡 |
| 第 2.5 层 | Traveling Merchant A | 旅行商人事件 | 可购入 1 张额外卡牌加入滞留位或背包 |
| 第 3 层 | Pivot | 背包卡可自由使用 | 引入反制性卡牌 |
| 第 4 层 | Pressure | 引入高倍率卡 | 增加副作用概率 |
| 第 4.5 层 | Traveling Merchant B | 旅行商人事件 | 商人卡可跨层携带 |
| 第 5 层 | Verdict | 最终对决 | 存在更多胜利碎片 |

胜负条件：五局三胜；任一玩家收集 3 枚「胜利碎片」立即绝杀。

## 🗂️ 源码目录规划

```text
src/
  game/
    types.ts          // 核心类型定义与常量
    cards.ts          // 卡牌原型与实例化工厂
    levels.ts         // 层级配置、卡池构建逻辑
    engine.ts         // 回合/结算/胜利判定的纯函数

  components/
    CardDisplay.tsx   // 卡牌及提示的展示组件
    PlayerHUD.tsx     // 玩家得分、滞留位、碎片信息
    MerchantModal.tsx // 旅行商人事件界面
    TurnLog.tsx       // 关键事件日志 & 提示

  App.tsx             // 顶层 UI，协调状态机
  App.css             // 页面排版与主题
```

## 🔄 游戏核心流程

1. **层级初始化**：
   - 双方 $score=1$，保留滞留位与背包。
   - 根据 `levels.ts` 构建并洗牌当层卡堆，生成公开信息（稀有度、胜利碎片分布）。

2. **玩家阶段**：
   - 每位玩家基础可抽 3 张，最多 5 张；额外抽卡权由卡牌效果累积。
   - 每次抽牌后可 **立即结算**、**放入滞留位**（仅 1 格）或 **丢弃**。
   - 滞留位卡牌可在任意时机释放，连续释放会形成 combo。

3. **AI/对手阶段**：
   - 简易策略：优先保留高倍率卡于滞留位；若分数低于对手显著落后，则冒险抽到 5 次。
   - AI 也会使用胜利碎片与层通行证。

4. **结算阶段**：
   - 应用层通行证（`max(score, 50)` 等）等延迟效果。
   - 比较双方分数，记录胜负局数。
   - 检查是否触发旅行商人或比赛胜利。

5. **旅行商人阶段**（2.5 / 4.5）：
   - 提供 3 张随机精选卡（来源于下一层卡池加特殊事件卡）。
   - 玩家仅能购入 1 张，消耗当层积分赎买值（默认 10 分或一张持有卡）。
   - 购入卡可选择放入滞留位或背包（下一层开始才能使用）。

## 🃏 卡牌体系

| 分类 | 代表卡 | 效果 | 备注 |
| --- | --- | --- | --- |
| 运算卡 | 连锁加法、暴击倍增 | `add`, `multiply` | 决定主要分数走势 |
| 风险卡 | 归零试胆、负向迁移 | `reset`, `steal` | 造成高风险高收益 |
| 资源卡 | 时间扭曲、抽牌加速 | `extraDraw`, `duplicate` | 建立节奏优势 |
| 胜利碎片 | 「命运碎片」 | `victoryShard` | 收集 3 枚瞬杀 |
| 通行证 | “x层通行证” | `levelPass` | 结算时保底 50 分，可跨层携带 |
| 商人限定 | 秘密交换、护甲护盾 | `shield`, `swap` | 仅旅行商人提供 |

详细原型见 `cards.ts`，每张卡都会在实例化时生成随机数值（例如 $\pm2\sim\pm8$ 的加减幅度），并以稀有度控制出现概率。

## ⚙️ 状态机设计

- `GameState.phase`: `'playerTurn' | 'aiTurn' | 'levelEnd' | 'merchant' | 'matchEnd'`
- `GameState.level`: 1-5，半层用 `merchant` phase 标识。
- `PlayerState`：维护 `score`、`drawsUsed`、`extraDraws`、`holdCard`、`backpack`、`victoryShards`、`wins`、`passTokens`。
- `DeckState`：`drawPile`、`discardPile`、`publicInfo`（剩余胜利碎片、稀有卡数量）。
- `LogEntry`：时间戳、事件类型、描述文本，用于 UI 日志回放。

所有数值运算通过 `engine.ts` 中的纯函数完成，React 组件只负责触发动作和展示结果。

## 🧠 主要交互逻辑

- **抽牌**：`engine.drawCard()` 返回新的 `GameState` + 抽到的 `CardInstance`。
- **使用卡牌**：`engine.resolveCard()` 根据 `CardEffect` 类型计算分数或状态。
- **滞留位释放**：`engine.releaseHold()`，支持多张连锁时的加成描述。
- **回合结束**：`engine.completeTurn()` 自动触发延迟效果、AI 行动和胜利判断。
- **旅行商人**：`engine.presentMerchant()` 生成报价列表，`engine.acceptOffer()` 更新玩家库存。

## 🛠️ 技术实现规划

1. **数据层**：先完成 `types.ts`、`cards.ts`、`levels.ts` 与 `engine.ts`，确保可通过单元测试验证核心逻辑。
2. **UI 层**：
   - 顶部：层级/胜场/碎片概览。
   - 中部：双方面板 + 日志。
   - 底部：操作面板（抽牌、使用、滞留位控制、结束回合）。
   - 弹窗：旅行商人与关键事件。
3. **AI 策略**：简单优先级 + 随机因素，逐步可调。
4. **测试**：计划加入 `vitest` 针对 `engine.ts` 的纯函数测试（后续迭代完成）。

## 🚀 开发里程碑

- [x] 设计文档与目录规划
- [ ] 核心引擎函数
- [ ] UI 组件与交互
- [ ] 旅行商人事件
- [ ] AI 策略调优
- [ ] 自动化测试覆盖

随后章节将由代码实现同步推进，本存储库 README 将在主要里程碑后更新。
